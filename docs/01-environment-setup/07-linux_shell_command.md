# 리눅스 쉘과 명령어 실행 원리

## 1. 쉘(shell)이란 무엇인가

리눅스에서 **쉘(shell)** 은
사용자가 입력한 명령어를 받아서
운영체제에 전달하고, 그 결과를 다시 보여주는 **중간 프로그램**이다.

즉,

> **쉘은 사람과 리눅스 커널 사이의 통역기 역할**을 한다.

---

### 쉘이 하는 일

쉘은 다음 작업을 담당한다.

* 사용자가 입력한 명령어 해석
* 실행 파일 검색 (PATH 사용)
* 프로그램 실행
* 결과 출력

예를 들어:

```bash
ls
```

이 명령을 입력하면,

1. 쉘이 `ls`라는 문자열을 해석한다
2. PATH 환경변수에서 `ls` 실행 파일을 찾는다
3. 해당 파일을 실행한다
4. 실행 결과를 화면에 출력한다

---

### Ubuntu 서버에서 기본으로 사용하는 쉘은 **bash**다.

* bash = Bourne Again SHell
* 리눅스에서 가장 널리 사용되는 쉘
* 이 강의에서 말하는 “쉘”은 기본적으로 bash를 의미한다

---

### 쉘과 터미널의 차이


| 구분  | 의미                          |
| --- | --------------------------- |
| 터미널 | 글자를 입력하고 결과를 보여주는 **화면/도구** |
| 쉘   | 명령어를 해석하고 실행하는 **프로그램**     |

즉,

> **터미널 안에서 쉘이 실행된다**

Windows Terminal, VS Code 터미널은
“터미널 프로그램”이고,
그 안에서 bash 쉘이 동작한다.

---

## 2. 리눅스 명령어는 어떻게 실행될까?

터미널에서 다음과 같이 입력하면
현재 위치와 상관없이 항상 실행된다.

```bash
ls
pwd
whoami
```

이유는 이 명령어들이
**PATH 환경변수에 등록된 경로 안에 있기 때문**이다.

---

## 3. PATH 환경변수 확인

```bash
echo $PATH
```

출력 예:

```text
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

의미:

* 위 경로들 안에 있는 실행 파일은
* **파일명만 입력해도 실행 가능**

---

## 3-1. 서버에 접속하면 먼저 실행되는 설정 파일들

SSH로 서버에 접속하거나 터미널을 열면,
리눅스는 **아무 명령도 치기 전에** 몇 가지 설정 파일을 자동으로 읽는다.

이 설정 파일들에서
환경변수(PATH 등)가 준비된다.

즉,

> **명령어를 실행하기 전에
> 먼저 “명령어를 실행할 수 있는 환경”이 만들어진다.**

---

### bash 환경에서 실행되는 주요 설정 파일

Ubuntu 서버의 기본 쉘은 `bash`이며,
다음 설정 파일들이 사용된다.

| 파일             | 역할                       |
| -------------- | ------------------------ |
|  **`/etc/environment`**   | PAM 단계. 시스템 기본 환경변수 정의 **주 설정 위치** |
| `/etc/profile` | 모든 사용자에게 공통으로 적용되는 전역 설정 |
| `~/.profile`   | 로그인 시 사용자 환경 설정          |
| `~/.bashrc`    | 쉘 실행 시마다 적용되는 설정         |

---

### `.profile` 과 `.bashrc` 차이

| 구분    | `.profile` | `.bashrc`      |
| ----- | ---------- | -------------- |
| 실행 시점 | 로그인 시      | 쉘 시작 시         |
| 적용 범위 | 사용자 세션 전체  | 현재 터미널         |
| 주 용도  | 기본 환경변수    | alias, PATH 보강 |

> 보통 **PATH의 기본값은 `.profile`**,
> 추가 설정은 `.bashrc`에서 이루어진다.

---

## 로그인 쉘과 비로그인 쉘

### 로그인 쉘 (login shell)

* SSH로 서버에 처음 접속했을 때

실행 흐름:

```text
/etc/profile
→ ~/.profile
```

---

### 비로그인 쉘 (non-login shell)

* 이미 로그인된 상태에서 터미널을 새로 열었을 때

실행 흐름:

```text
~/.bashrc
```

---

### PATH는 이렇게 만들어진다

```bash
echo $PATH
```

이 값은 **원래 존재하는 값이 아니라**,
설정 파일들이 순서대로 실행되며
누적되어 만들어진 결과다.

---

## 2-2. 설정 파일을 즉시 반영하는 방법 (source)

설정 파일을 수정했더라도
이미 열려 있는 터미널에는 **즉시 반영되지 않는다**.

이때 사용하는 명령이 `source` 다.

```bash
source ~/.bashrc
```

의미:

> **현재 쉘에서 설정 파일을 다시 읽어 실행한다**

* 새 터미널을 열지 않아도
* PATH, alias 등의 설정이 바로 적용된다

---

## 3. 명령어의 실제 위치 확인

`ls` 명령어가 실제로 어디에 있는지 확인한다.

```bash
which ls
```

출력 예:

```text
/usr/bin/ls
```

→ `/usr/bin`은 PATH에 포함된 디렉터리이기 때문에
`ls`를 어디서든 실행할 수 있다.

---

## 4. 나만의 명령어 만들어보기

이제 간단한 스크립트를 만들어
`ls`처럼 **어디서든 실행**되게 해본다.

---

### 4-1. 스크립트 작성

```bash
sudo tee /usr/local/bin/hello-server << 'EOF'
#!/usr/bin/env bash

echo "Hello Server"
echo "user=$(whoami)"
echo "current_dir=$(pwd)"
EOF
```

---

### 4-2. 실행 권한 부여

```bash
sudo chmod +x /usr/local/bin/hello-server
```

리눅스에서는
**실행 권한이 있어야 파일을 실행할 수 있다.**

---

### 4-3. 어디서든 실행해보기

```bash
cd /
hello-server

cd ~
hello-server
```

설명:

* `/usr/local/bin`은 PATH에 포함된 경로
* 그래서 `hello-server`를 **명령어처럼 실행 가능**

---

## 5. 핵심 개념 정리

### 5-1. PATH 환경변수

* 실행 파일을 찾는 **검색 경로 목록**
* PATH에 포함된 디렉터리에 있으면
  파일명만으로 실행 가능

---

### 5-2. 리눅스 명령어의 정체

* `ls`, `pwd`, `whoami`는 모두 실행 파일
* 특별한 문법이 아니라
  **그냥 파일을 실행하는 것**

---

## 이 장의 핵심 메시지

* 명령어는 바로 실행되는 것이 아니다
* 쉘 시작 → 설정 파일 실행 → PATH 구성 → 명령어 실행
* 환경이 먼저 준비되기 때문에 명령어가 동작한다

---

## 다음 단계

→ [**08. Nginx 웹 서버 설치 및 동작 확인**](08-nginx_install_check.md)
