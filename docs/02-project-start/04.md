# 인터페이스 도입

> **구현과 사용을 분리**하고,
> 저장 방식이 바뀌어도 **Service 코드는 바뀌지 않는 이유**를 코드로 이해한다.

---

## 1. 이번 실습에서 확인할 질문

* 인터페이스는 왜 필요한가?

---

## 2. 현재 구조의 한계

지금 구조에서는 Service가 **구현체 클래스**에 의존한다.

```java
private final UserRepository userRepository;
```

지금은 문제가 없어 보이지만,
저장 방식이 바뀌면 어떻게 될까?

* 메모리 저장 → 파일 저장
* 메모리 저장 → DB 저장

---

## 3. Repository를 인터페이스로 분리

### 1) 인터페이스 정의 (규약)

```java
public interface UserRepository {

    boolean exists(String username);

    void save(String username);
}
```

* **무엇을 할 수 있는지**만 정의

---

### 2) 메모리 기반 구현체

```java
import java.util.ArrayList;
import java.util.List;

public class MemoryUserRepository implements UserRepository {

    private final List<String> users = new ArrayList<>();

    @Override
    public boolean exists(String username) {
        return users.contains(username);
    }

    @Override
    public void save(String username) {
        users.add(username);
        System.out.println("[MemoryRepository] 사용자 저장: " + username);
    }
}
```

- `List<String>`은 이 List에는 String만 들어올 수 있다는 타입 약속(제네릭)이다.

---

## 4. Service 코드는 바뀌지 않는다

```java
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void join(String username) {

        if (userRepository.exists(username)) {
            throw new RuntimeException("이미 존재하는 사용자");
        }

        userRepository.save(username);
    }
}
```

* Service는 **인터페이스만** 의존
* 구현체 변경에 영향 없음

---

## 5. 구현체 교체 실습

### App(main)에서 조립만 변경

기존 코드
```java
UserRepository repo = new UserRepository();
```

아래로 교체
```java
UserRepository repo = new MemoryUserRepository();
```

다음과 같이 바뀌어도 Service는 그대로다.

```java
UserRepository repo = new FileUserRepository(); // 가정
```

---

## 6. 왜 인터페이스를 쓰는가 (핵심)

* 교체 가능성
* 테스트 용이성
* 의존성 방향 고정

> **Service → 인터페이스 ← 구현체**

---

## 7. 스프링과 연결

| 순수 자바                | 스프링에서        |
| -------------------- | ------------ |
| 조립 코드(main)에서 구현체 선택 | 컨테이너가 구현체 선택 |
| 생성자에 의존성 전달          | 생성자 주입       |
| new 직접 사용            | new 자동 관리    |

> 스프링은 **구현체를 대신 골라주는 조립기**다

---



## 다음 단계

* `Map<String, Object>` = Row
* `List<Map<String, Object>>` = ResultSet
* JDBC 결과 구조 자연스럽게 연결

→ [**Map / List로 DB 결과 흉내내기**](05.md)