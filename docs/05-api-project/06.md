# 06. 인가 (403) — 관리자 전용 사용자 조회 제어

이 문서는 05단계(인증, 401) 이후
**인증은 되었으나 권한이 없는 경우를 403(FORBIDDEN)으로 차단**하는 기준을 정의한다.

본 단계에서는 **Users 조회 기능을 관리자 전용으로 제한**하고,
이를 실제로 동작시키기 위한 **DB Role 설계 + Repository + Filter + SecurityConfig 전체 코드**를 포함한다.

---

## 1. 이 단계의 목표

서버는 다음 규칙을 만족해야 한다.

1. 로그인하지 않은 사용자는 `/api/**` 접근 시 401로 차단된다 (05단계에서 완료)
2. 로그인한 사용자라도, **관리자 권한이 없으면 사용자 조회 API에 접근할 수 없다**
3. 권한 부족 시 응답은 **403 FORBIDDEN + ApiResponse(JSON)** 으로 통일된다
4. Controller나 Service에서 권한을 직접 판단하지 않는다
   → **요청 진입 지점(SecurityFilterChain)에서 차단**

---

## 2. 401과 403의 책임 분리

| 상태 코드            | 의미              | 판단 주체           |
| ---------------- | --------------- | --------------- |
| 401 UNAUTHORIZED | 인증 실패 (로그인 안 됨) | Security Filter |
| 403 FORBIDDEN    | 인증은 되었으나 권한 없음  | Security Filter |

> **인가(403)는 “로그인 이후 단계의 문제”다.**

---

## 3. 인가 정책 결정

### 관리자만 가능한 기능

* 사용자 목록 조회
  `GET /api/users`
* 사용자 단건 조회
  `GET /api/users/{id}`

### 일반 로그인 사용자 가능

* 내 정보 조회
  `GET /api/me`

### 인증 없이 허용

* 회원가입
  `POST /api/users`
* 로그인
  `POST /api/login`

---

## 4. Role 테이블 구성 및 관리자 권한 부여

### roles 테이블

```sql
CREATE TABLE roles (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(50) NOT NULL UNIQUE
);
```

### user_roles 테이블

```sql
CREATE TABLE user_roles (
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  PRIMARY KEY (user_id, role_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);
```

### 기본 Role 데이터

```sql
INSERT INTO roles (name) VALUES ('ROLE_USER'), ('ROLE_ADMIN');
```

### 관리자 Role 부여

```sql
INSERT INTO user_roles (user_id, role_id)
SELECT u.id, r.id
FROM users u
JOIN roles r ON r.name = 'ROLE_ADMIN'
WHERE u.username = 'admin';
```

---

## 5. Role 조회 Repository

### UserRoleRepository

```java
package com.koreanit.spring.repository;

import java.util.List;

public interface UserRoleRepository {
  List<String> findRoleNamesByUserId(Long userId);
}
```

### JdbcUserRoleRepository

```java
package com.koreanit.spring.repository.impl;

import com.koreanit.spring.repository.UserRoleRepository;
import java.util.List;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class JdbcUserRoleRepository implements UserRoleRepository {

  private final JdbcTemplate jdbcTemplate;

  public JdbcUserRoleRepository(JdbcTemplate jdbcTemplate) {
    this.jdbcTemplate = jdbcTemplate;
  }

  @Override
  public List<String> findRoleNamesByUserId(Long userId) {
    String sql = """
        SELECT r.name
        FROM user_roles ur
        JOIN roles r ON r.id = ur.role_id
        WHERE ur.user_id = ?
        """;

    return jdbcTemplate.queryForList(sql, String.class, userId);
  }
}
```

---

## 6. SessionAuthenticationFilter (Role 주입)

```java
package com.koreanit.spring.security;

import com.koreanit.spring.repository.UserRoleRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import java.io.IOException;
import java.util.List;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

public class SessionAuthenticationFilter extends OncePerRequestFilter {

  public static final String SESSION_USER_ID = "LOGIN_USER_ID";

  private final UserRoleRepository userRoleRepository;

  public SessionAuthenticationFilter(UserRoleRepository userRoleRepository) {
    this.userRoleRepository = userRoleRepository;
  }

  @Override
  protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain)
      throws ServletException, IOException {

    Authentication cur = SecurityContextHolder.getContext().getAuthentication();

    if (cur == null || cur instanceof AnonymousAuthenticationToken) {
      HttpSession session = request.getSession(false);
      if (session != null) {
        Object v = session.getAttribute(SESSION_USER_ID);

        if (v instanceof Long userId) {
          List<String> roles = userRoleRepository.findRoleNamesByUserId(userId);

          if (roles.isEmpty()) {
            roles = List.of("ROLE_USER");
          }

          var authorities = roles.stream()
              .map(SimpleGrantedAuthority::new)
              .toList();

          var auth = new UsernamePasswordAuthenticationToken(
              userId,
              null,
              authorities
          );

          SecurityContextHolder.getContext().setAuthentication(auth);
        }
      }
    }

    filterChain.doFilter(request, response);
  }
}
```

---

## 7. SecurityConfig (06 최종)

```java
package com.koreanit.spring.security;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.koreanit.spring.common.error.ErrorCode;
import com.koreanit.spring.common.response.ApiResponse;
import com.koreanit.spring.repository.UserRoleRepository;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
public class SecurityConfig {

  private final ObjectMapper objectMapper;
  private final UserRoleRepository userRoleRepository;

  public SecurityConfig(ObjectMapper objectMapper, UserRoleRepository userRoleRepository) {
    this.objectMapper = objectMapper;
    this.userRoleRepository = userRoleRepository;
  }

  private void writeJson(HttpServletResponse res, int status, ApiResponse<Void> body) {
    res.setStatus(status);
    res.setContentType("application/json; charset=UTF-8");

    try {
      objectMapper.writeValue(res.getWriter(), body);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
  }

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {

    http
        .formLogin(f -> f.disable())
        .httpBasic(b -> b.disable())
        .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED))
        .csrf(csrf -> csrf.disable())

        .exceptionHandling(e -> e
            .authenticationEntryPoint((req, res, ex) -> {
              writeJson(res,
                  ErrorCode.UNAUTHORIZED.getStatus().value(),
                  ApiResponse.fail(ErrorCode.UNAUTHORIZED.name(), "로그인이 필요합니다"));
            })
            .accessDeniedHandler((req, res, ex) -> {
              writeJson(res,
                  ErrorCode.FORBIDDEN.getStatus().value(),
                  ApiResponse.fail(ErrorCode.FORBIDDEN.name(), "권한이 없습니다"));
            }))

        .authorizeHttpRequests(auth -> auth
            .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
            .requestMatchers(HttpMethod.POST, "/api/users").permitAll()
            .requestMatchers(HttpMethod.POST, "/api/login").permitAll()
            .requestMatchers(HttpMethod.GET, "/api/me").authenticated()
            .requestMatchers(HttpMethod.GET, "/api/users").hasRole("ADMIN")
            .requestMatchers(HttpMethod.GET, "/api/users/*").hasRole("ADMIN")
            .requestMatchers("/api/**").authenticated()
            .anyRequest().permitAll())

        .logout(lo -> lo
            .logoutUrl("/api/logout")
            .invalidateHttpSession(true)
            .deleteCookies("JSESSIONID")
            .logoutSuccessHandler((req, res, auth) -> {
              writeJson(res, 200, ApiResponse.ok(null));
            }))

        .addFilterBefore(
            new SessionAuthenticationFilter(userRoleRepository),
            UsernamePasswordAuthenticationFilter.class
        );

    return http.build();
  }
}
```

---

## 8. 체크리스트

* 관리자 Role은 DB 기준으로 관리된다
* SecurityContext에 주입된 Role만 인가 판단에 사용된다
* 테이블만 생성해서는 인가가 동작하지 않는다
* Role 조회 + Filter + SecurityConfig가 모두 필요하다
