# Node.js 워커 구현을 위한 핵심 문법 정리

이 문서는  
이후 구현할 Node.js 워커 엔트리포인트(`worker.js`)를  
이해하기 위해 필요한 **최소한의 Node.js / JavaScript 문법만 정리**한다.

이 문서를 기준으로,  
이후 문서에서는 개별 문법 설명을 반복하지 않는다.

---

## 1. Node.js 프로그램의 실행 모델

### 1-1. Node.js는 "서버"가 아니라 "실행기"다

Node.js는 JavaScript를 실행하는 런타임 환경이다.  
HTTP 서버는 선택 사항이며, 워커 프로그램에서는 사용하지 않는다.

워커는 다음 구조를 가진다.

```
실행 → 작업 수행 → 종료
```

실행 예:

```bash
node src/worker.js
```

중요한 특징:

* `main()` 함수가 없다
* **파일 자체가 진입점(entry point)** 이다
* 코드가 **위에서 아래로 즉시 실행**된다

---

## 2. 모듈 시스템 (CommonJS)

### 2-1. CommonJS를 사용하는 이유

이 워커 프로젝트는 **CommonJS 모듈 시스템**을 사용한다.

```json
"type": "commonjs"
```

이는 Node.js의 기본 모듈 방식이며, 다음과 같은 이유로 선택한다.

* Spring의 **패키지 / 클래스 구조**와 개념적으로 유사하다
  → 파일 하나가 하나의 책임을 가진 모듈 역할을 한다
* 파일 단위로 **책임과 역할 분리**가 명확하다
* `require → 실행 → 공유` 흐름이 단순하여
  **의존성 흐름 설명에 유리**하다

---

### 2-2. require는 “불러오기”가 아니라 “실행 + 캐싱”이다

다음 코드를 보자.

```js
const pool = require("./db/pool");
```

많은 초보자는 `require`를
“파일을 불러오는 문법” 정도로 이해한다.
하지만 실제 동작은 더 명확하다.

`require()`의 동작 순서는 다음과 같다.

1. 해당 파일을 **처음 만났을 때**

   * 파일 내부의 **코드를 즉시 실행**
2. 실행 결과로 만들어진 `module.exports`를

   * **Node.js 내부 캐시**에 저장
3. 이후 같은 파일을 다시 `require`하면

   * 코드를 다시 실행하지 않고
     **캐시된 객체를 그대로 반환**

---

### 이 구조가 중요한 이유

이 프로젝트에서는 DB 커넥션 풀을 다음과 같이 관리한다.

```js
// db/pool.js
const mysql = require("mysql2/promise");

const pool = mysql.createPool({
  // connection options
});

module.exports = pool;
```

이 파일이 처음 `require`될 때:

* 커넥션 풀이 **단 한 번만 생성**되고
* 그 결과가 캐시에 저장된다

이후 어떤 파일에서든

```js
require("./db/pool");
```

을 호출하면:

* 새로운 풀을 만드는 것이 아니라
* **같은 풀 인스턴스를 공유**하게 된다

---

### 정리

CommonJS에서 `require`는 다음 의미를 가진다.

* 파일을 읽는다 ❌
* 코드를 실행한다 ⭕
* 실행 결과를 캐시한다 ⭕
* 이후에는 같은 객체를 공유한다 ⭕

그래서 CommonJS는

> “전역 싱글톤을 안전하게 만드는 구조”

로 이해해도 된다.

이 특성 덕분에
워커 전체에서 **DB 커넥션, 설정 객체, 공통 로직**을
의도적으로 공유할 수 있다.

---

## 3. 비동기 처리 기본 (async / await)

### 3-1. 워커는 비동기 작업의 연속이다

워커에서 수행하는 작업은 대부분 비동기다.

* DB 접근
* 파일 읽기
* 네트워크 요청

기본 형태:

```js
async function run() {
  await job.execute();
}
```

원칙:

* `then / catch` 사용하지 않는다
* 모든 진입 함수는 `async`
* 에러는 처리하지 말고 **그대로 throw**

---

## 4. try-catch의 위치 원칙

워커에서는 `try-catch`를 **엔트리포인트에서만 사용**한다.

```js
try {
  await run();
  process.exit(0);
} catch (err) {
  console.error(err);
  process.exit(1);
}
```

이 구조의 의미:

* 내부 로직은 예외를 **발생시키는 책임만**
* 성공 / 실패 판단은 **최상위에서만**
* 워커의 결과는 **종료 코드로 표현**

---

## 5. process 객체와 종료 코드

### 5-1. exit code가 중요한 이유

워커는 보통 다음 환경에서 실행된다.

* cron
* CI/CD
* 운영 스크립트
* 수동 배치 실행

```js
process.exit(0); // 정상 종료
process.exit(1); // 실패 종료
```

중요한 점:

* 로그 메시지는 참고용
* **성공 / 실패의 기준은 종료 코드**

---

## 6. 환경 변수와 dotenv

워커의 설정값은 **코드에 하드코딩하지 않는다**.
실행 환경(개발, 테스트, 운영)에 따라 달라질 수 있는 값은 모두 **환경 변수**로 관리한다.

Node.js 워커에서는 `dotenv` 라이브러리를 사용하여
`.env` 파일에 정의된 환경 변수를 애플리케이션 실행 시 로드한다.

```js
require("dotenv").config();
```

---

### 적용 원칙

* **`.env` 파일은 실행 환경의 책임**이다
  (개발 환경과 운영 환경은 서로 다른 값을 가질 수 있다)
* **코드와 설정을 분리**하여
  코드 재사용성과 배포 안정성을 높인다
* 환경 변수는 **설정 값이지 로직이 아니다**

> 즉,
> **코드는 항상 동일하게 유지하고,
> 동작 방식은 환경 변수로 제어한다**



---

## 다음 단계

다음 문서에서는  
지금 정리한 문법을 전제로,  
Node.js 워커의 실제 엔트리포인트(`worker.js`)를 구현한다.

→ [**워커 엔트리포인트 구현**](03-worker_entrypoint.md)
